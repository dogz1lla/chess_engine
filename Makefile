# --- Makefile for C Project with two executables ---
#  this file is generated by an LLM, watch out broski.

# Compiler and Flags
CC = gcc
CFLAGS = -Wall -Wextra -pedantic
# Adding -Werror to CFLAGS for the main project,
# but note it is excluded from the websocket target to match the original script.

# Define the two executable targets
TARGETS = chess ws_example

# --- Source Files ---

# Source files for the main 'chess' executable
CHESS_SRCS = chess.c bitboard.c set_operations.c one_step.c
CHESS_OBJS = $(CHESS_SRCS:.c=.o)

# Source files for the 'ws_example' executable
# These include the example code and all the library source files
WS_EXAMPLE_SRCS = \
    ws_example.c \
    lib/wsServer/src/ws.c \
    lib/wsServer/src/utf8.c \
    lib/wsServer/src/handshake.c \
    lib/wsServer/src/sha1.c \
    lib/wsServer/src/base64.c

# Include paths for the websocket library
WS_INCLUDE = -Ilib/wsServer/src -Ilib/wsServer/include

# --- Phony Targets ---

.PHONY: all clean

# The default target: builds both executables
all: $(TARGETS)

# --- Target: chess (Normal Executable) ---

# Rule to build the main 'chess' executable
chess: $(CHESS_SRCS)
	$(CC) $(CFLAGS) -Werror $^ -o $@

# --- Target: ws_example (WebSocket Executable) ---

# Rule to build the 'ws_example' executable
ws_example: $(WS_EXAMPLE_SRCS)
	$(CC) $(CFLAGS) $(WS_INCLUDE) $^ -o $@

# --- Cleanup Rule ---

# Rule to remove all generated files
clean:
	rm -f $(TARGETS)
	# If you switch to using .o files (recommended for larger projects)
	# you would also need to add: rm -f *.o
